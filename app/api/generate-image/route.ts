import { type NextRequest, NextResponse } from "next/server"

export async function POST(request: NextRequest) {
  try {
    const { prompt, model, apiKey, inputImages } = await request.json()

    if (!apiKey) {
      return NextResponse.json({ error: "API key is required" }, { status: 400 })
    }

    let imageUrl: string

    if (model.startsWith("gemini")) {
      imageUrl = await generateWithGemini(prompt, apiKey, inputImages)
    } else {
      imageUrl = `/placeholder.svg?height=400&width=400&query=${encodeURIComponent(prompt + " generated image")}`
    }

    return NextResponse.json({ imageUrl })
  } catch (error) {
    console.error("Image generation error:", error)
    return NextResponse.json({ error: "Failed to generate image" }, { status: 500 })
  }
}

async function generateWithGemini(prompt: string, apiKey: string, inputImages: string[]): Promise<string> {
  try {
    const { GoogleGenAI } = await import("@google/genai")
    const ai = new GoogleGenAI({
      apiKey: apiKey,
    })

    const config = {
      responseModalities: ["IMAGE", "TEXT"],
    }

    const model = "gemini-2.5-flash-image-preview"

    const parts: any[] = [{ text: prompt }]

    if (inputImages && inputImages.length > 0) {
      for (const imageUrl of inputImages) {
        if (imageUrl.startsWith("data:")) {
          const base64Data = imageUrl.split(",")[1]
          const mimeType = imageUrl.split(";")[0].split(":")[1]
          parts.push({
            inlineData: {
              data: base64Data,
              mimeType: mimeType,
            },
          })
        } else if (imageUrl.startsWith("/placeholder.svg")) {
          continue
        } else {
          try {
            const response = await fetch(imageUrl)
            const buffer = await response.arrayBuffer()
            const base64 = Buffer.from(buffer).toString("base64")
            parts.push({
              inlineData: {
                data: base64,
                mimeType: response.headers.get("content-type") || "image/jpeg",
              },
            })
          } catch (fetchError) {
            console.warn("Failed to fetch image:", imageUrl, fetchError)
          }
        }
      }
    }

    const contents = [
      {
        role: "user",
        parts: parts,
      },
    ]

    const response = await ai.models.generateContentStream({
      model,
      config,
      contents,
    })

    for await (const chunk of response) {
      if (!chunk.candidates || !chunk.candidates[0].content || !chunk.candidates[0].content.parts) {
        continue
      }

      if (chunk.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
        const inlineData = chunk.candidates[0].content.parts[0].inlineData
        const mimeType = inlineData.mimeType || "image/png"
        const base64Data = inlineData.data || ""
        return `data:${mimeType};base64,${base64Data}`
      }
    }

    console.warn("No image generated by Gemini model")
    return `/placeholder.svg?height=400&width=400&query=${encodeURIComponent("Image generation failed - " + prompt)}`
  } catch (error: any) {
    console.error("Gemini generation error:", error)

    if (error.message && error.message.includes("exceeded your current quota")) {
      throw new Error(
        "QUOTA_EXCEEDED: You have exceeded your Gemini API quota. Please check your billing details or try again later.",
      )
    }

    if (error.message && error.message.includes("429")) {
      throw new Error("RATE_LIMITED: Too many requests. Please wait a moment and try again.")
    }

    throw new Error(`GENERATION_FAILED: ${error.message || "Unknown error occurred"}`)
  }
}
